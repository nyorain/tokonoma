#version 450

// invariants (before/after every exeuction):
// - fields.player == playerNone <=>
// 		(field.type == FieldEmpty && field.strength = 0.f);
// - fields.player != playerNone => (field.player < playerCount);

const uint playerCount = 2u; // TODO: only 2 works atm, see below

// symbolic special constants
const uint nextNone = 0xFFFFFFFF;
const uint playerNone = 0xFFFFFFFF;
const float oneSixth = 0.166;

// the amount of diffuse per difference in every step
// if one cell has strength 1 and its neighbor 0, so much will float
// into the neighbor. If two neighbor cells don't have the same
// player, the stronger one will gain the cell
// must be in range [0, 1/6]
const float diffuse = 0.01;
const float diffuseVel = 0.05;

// TODO: not used, just a concept atm. Work out clash model further
// we probably first want to track how many fighters from each player
// are there (from *all* neighbors) and then evaulate the fight and losses
// using this factor
//
// by how much if matters in a fight which side has more forces.
// must be in range [1, inf)
// if this is 1, the result of a fight will only be the net difference
// of fighting forces in both cells. If this goes against infinity,
// the stronger side will have less losses and the stronger side more.
const float advantageInfluence = 2;

// constant tower damage per tick
const float towerDamage = 0.01;

// constant strength spawned by building
const float spawnStrength = 0.001;

// influence factor of accelerator field
const float accelInfluence = 0.05;

// buildings
const uint FieldEmpty = 0u; // empty field
const uint FieldResource = 1u; // resource harvester
const uint FieldSpawn = 2u; // spawns strength
const uint FieldTower = 3u; // damages nearby enemies
const uint FieldAccel = 4u; // accelerates

// sides, order of Field.next
const uint SideRight = 0u;
const uint SideTopRight = 1u;
const uint SideTopLeft = 2u;
const uint SideLeft = 3u;
const uint SideBotLeft = 4u;
const uint SideBotRight = 5u;

const float sqrt2 = 1.41421356237;
const float isqrt2 = 0.70710678118;
const vec2 sideDirections[6] = {
	vec2(1, 0), // right
	vec2(isqrt2, isqrt2), // topRight
	vec2(-isqrt2, isqrt2), // topLeft
	vec2(-1, 0), // left
	vec2(-isqrt2, -isqrt2), // botLeft
	vec2(isqrt2, -isqrt2), // botRight
};

// Returns the logical direction of a SideXXX value
vec2 direction(uint side) {
	return sideDirections[side];
}

bool isBuilding(uint fieldType) {
	return fieldType != FieldEmpty;
}

// A Field in our grid
struct Field {
	vec2 _pos;
	uint type;
	float strength; // in [0, 1] for empty cells (?)
	vec2 velocity;
	uint player;
	uint next[6]; // direct neighbors
	float _;
};

// Information about a player
struct Player {
	uint resources; // should only be atomically accessed
	float _1, _2, _3; // padding
};

// TODO: test different settings for performance
layout(local_size_x = 1) in;

// the old buffer. All reads must be performed from this since the other
// buffer may be written by another execution. Holds that was written
// the last step
layout(set = 0, binding = 0, std430) readonly buffer OldFields {
	Field[] fields;
} old;

// must only be written since it values are otherwise undefined.
// the final state should be written into this
layout(set = 0, binding = 1, std430) writeonly buffer NewFields {
	Field[] fields;
} new;

// common data about the players
layout(set = 0, binding = 2, std430) buffer Players {
	Player[playerCount] players;
} players;

void main() {
	uint id = gl_GlobalInvocationID.x;
	Field field = old.fields[id];

	uint player = field.player;

	// NOTE: something like pressure?
	// fields that have more strength should (not just proportionally)
	// diffuse "stronger"

	// NOTE: fix nan velocities
	
	// diffuse
	// 1: depart/general
	float strength = field.strength;
	vec2 vel = field.velocity;
	float l = length(vel);
	uint freeOwn = 0;
	for(uint i = 0; i < 6; ++i) {
		if(field.next[i] == nextNone) {
			// edge condition
			if(field.type == FieldEmpty) {
				field.velocity -= 0.5 * dot(field.velocity, direction(i)) * direction(i);
			}

			continue;
		}


		const Field next = old.fields[field.next[i]];
		float fac = clamp(mix(oneSixth, 10 * dot(direction(i), vel), tanh(20 * l)), 0.0, 1.0);
		// float fac = clamp(10 * dot(direction(i), next.velocity), 0.0, 1.0);
		if(next.type == FieldEmpty) {
			if(next.player == field.player) {
				++freeOwn;
			}

			if(field.type == FieldEmpty) {
				if(strength > 1.0) {
					field.velocity += 0.05 * direction(i) * (strength - next.strength);
				}
				// field.velocity += 0.01 * direction(i) * (strength - next.strength);

				// attack/diffuse: field -> next
				field.strength -= fac * diffuse * strength;
				field.velocity -= fac * diffuseVel * strength * vel;
			}
		}
	}

	// resources
	if(field.type == FieldResource) {
		atomicAdd(players.players[field.player].resources, freeOwn);
	}

	// slow down over time
	field.velocity *= 0.99999;

	// 2: receive
	float strengths[playerCount] = {0.0, 0.0}; // player strengths in this field
	vec2 velSum = vec2(0.0, 0.0); // weighted total velocity sum
	for(uint i = 0; i < 6; ++i) {
		if(field.next[i] == nextNone) {
			continue;
		}

		const Field next = old.fields[field.next[i]];
		float l = length(next.velocity);
		float fac = clamp(mix(oneSixth, 10 * dot(-direction(i), next.velocity), tanh(20 * l)), 0.0, 1.0);
		// float fac = clamp(10 * dot(-direction(i), next.velocity), 0.0, 1.0);

		// TODO: strength cannot be greater than 1? normalize somehow everywhere!
		// can't move into friendly building, only to attack
		if(next.type == FieldEmpty && (field.type == FieldEmpty || next.player != field.player)) {
			// diffuse (friendly or attack): next -> field
			strengths[next.player] += fac * diffuse * next.strength;
			velSum += fac * diffuseVel * next.strength * next.velocity;
		} else if(next.type == FieldTower && next.player != field.player) {
			field.strength -= towerDamage;
		} else if(next.type == FieldSpawn && strengths[next.player] < 1.f) {
			// spawn without any velocity
			strengths[next.player] += spawnStrength;
		} else if(next.type == FieldAccel && next.player == field.player) {
			velSum += field.strength * accelInfluence * next.velocity; // accelerate
		}
	}

	field.strength = max(0.0, field.strength);
	if(field.player != playerNone) {
		strengths[field.player] += field.strength;
		velSum += field.velocity;
	}

	// 3: fight
	uint bestPlayer = playerNone;
	float highestStrength = 0.0;
	float sum = 0.0; // TODO: simple sum doesn't work for playerCount > 2
	for(uint i = 0; i < playerCount; ++i) {
		sum += strengths[i];
		if(strengths[i] > highestStrength) {
			bestPlayer = i;
			highestStrength = strengths[i];
		}
	}

	// change field ownership/destroy building
	if(bestPlayer != field.player) {
		field.type = FieldEmpty; // destroy building if one is left
		// velSum = vec2(0.0, 0.0); // no velocity after invasion
	}

	field.strength = 2 * highestStrength - sum; // remainder
	field.player = bestPlayer;
	if(bestPlayer != playerNone) {
		field.velocity = velSum;
	}

	// write back
	new.fields[id] = field;
}
