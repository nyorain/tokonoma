#version 450

// invariants (before/after every exeuction):
// - fields.player == playerNone <=>
// 		(field.type == FieldEmpty && field.strength = 0.f);
// - fields.player != playerNone => (field.player < playerCount);

const uint playerCount = 2u; // TODO: only 2 works atm, see below

// symbolic special constants
const uint nextNone = 0xFFFFFFFF;
const uint playerNone = 0xFFFFFFFF;

// the amount of diffuse per difference in every step
// if one cell has strength 1 and its neighbor 0, so much will float
// into the neighbor. If two neighbor cells don't have the same
// player, the stronger one will gain the cell
// must be in range [0, 1/6]
const float diffuse = 0.1;

// TODO: not used, just a concept atm. Work out clash model further
// we probably first want to track how many fighters from each player
// are there (from *all* neighbors) and then evaulate the fight and losses
// using this factor
//
// by how much if matters in a fight which side has more forces.
// must be in range [1, inf)
// if this is 1, the result of a fight will only be the net difference
// of fighting forces in both cells. If this goes against infinity,
// the stronger side will have less losses and the stronger side more.
const float advantageInfluence = 2;

// constant tower damage per tick
const float towerDamage = 0.01;

// constant strength spawned by building
const float spawnStrength = 0.01;

// buildings
const uint FieldEmpty = 0u; // empty field
const uint FieldResource = 1u; // resource harvester
const uint FieldSpawn = 2u; // spawns strength
const uint FieldTower = 3u; // damages nearby enemies

// sides, order of Field.next
const uint SideRight = 0u;
const uint SideTopRight = 1u;
const uint SideTopLeft = 2u;
const uint SideLeft = 3u;
const uint SideBotLeft = 4u;
const uint SideBotRight = 5u;

const vec2 sideDirections[6] = {
	vec2(1, 0), // right
	vec2(1, 1), // topRight
	vec2(-1, 1), // topLeft
	vec2(-1, 0), // left
	vec2(-1, -1), // botLeft
	vec2(1, -1), // botRight
};

// Returns the logical direction of a SideXXX value
vec2 direction(uint side) {
	return sideDirections[side];
}

bool isBuilding(uint fieldType) {
	return fieldType != FieldEmpty;
}

// A Field in our grid
struct Field {
	float _x; // packed pos, ignored
	float _y; // packed pos, ignored
	uint player;
	uint type;
	float strength; // in [0, 1] for empty cells (?)
	uint next[6]; // direct neighbors

	// TODO: experimental
	// vec2 velocity;
};

// TODO: test different settings for performance
layout(local_size_x = 1) in;

// the old buffer. All reads must be performed from this since the other
// buffer may be written by another execution. Holds that was written
// the last step
layout(set = 0, binding = 0) readonly buffer OldFields {
	Field[] fields;
} old;

// must only be written since it values are otherwise undefined.
// the final state should be written into this
layout(set = 0, binding = 1) writeonly buffer NewFields {
	Field[] fields;
} new;

void main() {
	uint id = gl_GlobalInvocationID.x;
	Field field = old.fields[id];

	uint player = field.player;

	// diffuse
	// 1: depart/general
	float strength = field.strength;
	for(uint i = 0; i < 6; ++i) {
		if(field.next[i] == nextNone) {
			continue;
		}

		// float fac = dot(field.velocity, direction(i));
		const Field next = old.fields[field.next[i]];
		if(next.type == FieldEmpty) {
			if(field.type == FieldEmpty) {
				// attack/diffuse: field -> next
				field.strength -= diffuse * strength;
			}
		}
	}

	// 2: receive
	float strengths[playerCount] = {0.0, 0.0}; // player strengths in this field
	for(uint i = 0; i < 6; ++i) {
		if(field.next[i] == nextNone) {
			continue;
		}

		const Field next = old.fields[field.next[i]];
		if(next.type == FieldEmpty) {
			// diffuse (friendly or attack): next -> field
			strengths[next.player] += diffuse * next.strength;
		} else if(next.type == FieldTower && next.player != field.player) {
			field.strength -= towerDamage;
		} else if(next.type == FieldSpawn) {
			strengths[next.player] += spawnStrength;
		}
	}

	field.strength = max(0.0, field.strength);
	if(field.player != playerNone) {
		strengths[field.player] += field.strength;
	}

	// 3: fight
	uint bestPlayer = playerNone;
	float highestStrength = 0.0;
	float sum = 0.0; // TODO: simple sum doesn't work for playerCount > 2
	for(uint i = 0; i < playerCount; ++i) {
		sum += strengths[i];
		if(strengths[i] > highestStrength) {
			bestPlayer = i;
			highestStrength = strengths[i];
		}
	}

	// change field ownership/destroy building
	field.strength = 2 * highestStrength - sum; // remainder
	field.player = bestPlayer;
	if(bestPlayer != field.player) {
		field.type = FieldEmpty; // destroy building if one is left
	}

	// write back
	new.fields[id] = field;
}
