#version 450
#extension GL_GOOGLE_include_directive : enable

#include "noise.glsl"

// NOTE: care for alignment of struct.
// even with std430 there may be a padding at the end of the struct (?)
struct Particle {
	vec2 pos;
	vec2 vel;
	float lifetime;
	float alpha;
};

layout(local_size_x = 1) in;
layout(std430, set = 0, binding = 0) buffer Particles {
	Particle particles[];
};

layout(set = 0, binding = 1) uniform UBO {
	float dt; // time delta in seconds
	float time; // time in seconds
	uint pstype;
} ubo;

// out of bounds check
bool oob(vec2 pos) {
	return pos != clamp(pos, -1.f, 1.f);
}

void snow(uint index, inout Particle p) {
	p.vel *= exp(-0.5 * ubo.dt); // friction
	p.pos += p.vel * ubo.dt;
	p.lifetime -= ubo.dt;
	p.alpha = min(p.alpha + sign(p.lifetime - 1) * ubo.dt, 1);

	if(p.lifetime < 0 || p.pos.y > 1.f) {
		p.lifetime = 3 + 3 * random((1 + index) * (1 + ubo.time));
		p.pos.x = -1 + 2 * random(gradientNoise(p.vel) * sin(ubo.time) * index);
		p.pos.y = -1 + 2 * random(gradientNoise(-p.vel) * cos(ubo.time) * index);
		// p.pos.y = -1;
		p.vel = vec2(0);
		p.alpha = 0; // if lifetime ran out, this should be the case
	}

	// apply noised velocity
	// general wind-like velocity all particles should follow
	// but then each particle a changing factor
	// NOTE: would probably be better to use something like a particle mass for that?
	float wind = sgradientNoise(0.1 * ubo.time * vec2(1, 2));
	p.vel.x += 0.2 * ubo.dt * pow(2 * gradientNoise(ubo.time * vec2(index)), 6) * wind;
	p.vel.y += 0.4 * ubo.dt * gradientNoise(-1 + index * ubo.time * p.pos);
}

void radial(uint index, inout Particle p) {
	p.vel *= exp(-0.5 * ubo.dt); // friction
	p.pos += p.vel * ubo.dt;
	p.lifetime -= ubo.dt;
	p.alpha = min(p.alpha + sign(p.lifetime - 1) * ubo.dt, 1);

	if(p.lifetime < 0 || oob(p.pos)) { // reset
		p.lifetime = 1 + 3 * random((1 + index) * (1 + ubo.time));
		p.pos = vec2(0);
		p.vel = -1 + 2 * random2(vec2(1 + ubo.time, -1 + index));
		// p.vel.x = random(ubo.time * index);
		// p.vel.y = random(-ubo.time * index);
	}
}

void main() {
	// Current SSBO index; read particle
	uint index = gl_GlobalInvocationID.x;
	Particle p = particles[index];

	switch(ubo.pstype) {
		case 1:
			snow(index, p);
			break;
		case 2:
			radial(index, p);
			break;
	}

	// Write back
	particles[index] = p;
}

