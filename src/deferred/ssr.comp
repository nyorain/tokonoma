#version 450

#extension GL_GOOGLE_include_directive : enable
#include "scene.glsl"

// TODO: how to choose the best workgroup size? make it configurable!
layout(local_size_x = 8, local_size_y = 8) in;

layout(set = 0, binding = 0, row_major) uniform Scene {
	mat4 proj;
	mat4 invProj;
	vec3 viewPos;
	float near, far;
} scene;

layout(set = 1, binding = 0) uniform sampler2D linDepthTex;
layout(set = 1, binding = 1) uniform sampler2D normalTex;
layout(set = 1, binding = 2, rgba8) uniform writeonly image2D outData;

// parameters
// TODO: should be configurable; most based on scene size
// marchSteps: linear marching steps to find surface hit,
//   if too low, we might "march" completely through objects, i.e.
//   completely miss out on possible reflections
// binSteps: number of binary search steps used once a hit interval
//   has ben found. Increases precision of found hit exponentially.
const uint marchSteps = 16u; // linear marching steps
const uint binsSteps = 8u; // binary search steps after found hit interval
const float startStepSize = 0.01;
const float stepFactor = 2.0;

// TODO: add binary search end condition?: when pixel distance
//   on depthTex between lower and upper bounds positions is
//   smaller (user abs or max norm) than threshold bepx, stop
//   binary search. Not sure if worth it though if binsSteps
//   is so small anyways...
// TODO: don't always use lod level 0!
//   especially in first search step. Should bring performance
//   improvement. Really not sure how to determine the level to use though.
//   we step through world space, hard to tell how many pixels we skip.
const float lod = 0.0;

void main() {
	uvec2 size = imageSize(outData);
	uvec2 pixel = gl_GlobalInvocationID.xy;
	if(pixel.x >= size.x || pixel.y >= size.y) {
		// outside of range, can happen when texture size can't be evenly
		// devided into work groups
		imageStore(outData, ivec2(pixel), vec4(0.0));
		return;
	}

	vec2 pixelSize = 1.f / size;
	vec2 uv = pixel * pixelSize;

	float ld = textureLod(linDepthTex, uv, 0).r;
	float depth = ztodepth(ld, scene.near, scene.far);
	if(depth == 1.f) {
		// no pixel at this position; there won't be reflections
		imageStore(outData, ivec2(pixel), vec4(0.0));
		return;
	}

	vec2 suv = 2 * uv - 1;
	suv.y *= -1.f; // flip y
	vec4 pos4 = scene.invProj * vec4(suv, depth, 1.0);
	vec3 fragPos = pos4.xyz / pos4.w;
	vec3 normal = decodeNormal(textureLod(normalTex, uv, 0).xy);

	// ssr
	vec3 v = normalize(fragPos - scene.viewPos);	
	vec3 reflDir = reflect(v, normal);
	float fac = 1 - dot(-v, normal); // the steeper we look, the less reflections

	float stepSize = startStepSize;
	vec3 pos = fragPos;
	vec2 hitUV = vec2(0.0);
	float dist = 0;
	for(uint i = 0u; i < marchSteps; ++i) {
		vec3 lpos = pos; // last position
		pos += stepSize * reflDir;
		vec3 uv = sceneMap(scene.proj, pos);
		if(uv != clamp(uv, 0.0, 1.0)) {
			// the ray went out of bounds, no hit
			break;
		}

		float marchZ = depthtoz(uv.z, scene.near, scene.far);
		float sampleZ = textureLod(linDepthTex, uv.xy, lod).r;
		if(sampleZ >= marchZ) {
			// our ray is still in front of all surfaces.
			// continue with larger step size
			stepSize *= stepFactor;
			continue;
		}

		// we hit in this iteration and didn't hit the last iteration:
		// our ray crossed a surface. Use a binary search to determine
		// the hit point with higher accuracy.
		// Our solution always is in [lpos, pos]
		vec3 mid;
		for(uint j = 0; j < binsSteps; ++j) {
			mid = 0.5 * (lpos + pos);
			uv = sceneMap(scene.proj, mid);
			// we don't have to check if uv is in screen space bounds
			// here anymore (as we have to above) because this is only
			// an interpolation of two points known to be in bounds

			marchZ = depthtoz(uv.z, scene.near, scene.far);
			sampleZ = textureLod(linDepthTex, uv.xy, lod).r;
			if(sampleZ < marchZ) {
				pos = mid;	
			} else {
				lpos = mid;
			}
		}

		// check the normal of the found hit point. If dot(normal, rayDir)
		// is greater 0, that means we hit the surface from the back.
		// Pretty much the greates limit of ssr: in this case the
		// reflection would show something we currently just don't
		// have on the screen.
		vec3 sampleN = decodeNormal(textureLod(normalTex, uv.xy, 0).xy);
		if(dot(sampleN, reflDir) <= 0) {
			hitUV = uv.xy;
			dist = distance(fragPos, mid);
		}

		break;
	}

	imageStore(outData, ivec2(pixel), vec4(hitUV, fac, dist));
}
