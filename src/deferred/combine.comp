#version 450

#extension GL_GOOGLE_include_directive : enable
#include "scene.glsl"
#include "pbr.glsl"

// TODO: how to choose the best workgroup size? make it configurable!
layout(local_size_x = 8, local_size_y = 8) in;
layout(set = 0, binding = 0, row_major) uniform SceneUbo {
	mat4 proj;
	mat4 invProj;
	vec3 viewPos;
	float near, far;
} scene;

layout(set = 1, binding = 0, rgba16f) uniform image2D outCol;

layout(set = 1, binding = 1) uniform Params {
	uint mode;
	uint flags;
	float aoFactor;
	float ssaoPow;
	uint tonemap;
	float exposure;
	uint convolutionLods; // TODO: rather constant or specialization constant?
} params;

layout(set = 1, binding = 2) uniform sampler2D albedoTex;
layout(set = 1, binding = 3) uniform sampler2D ssaoTex;
layout(set = 1, binding = 4) uniform sampler2D emissionTex;
layout(set = 1, binding = 5) uniform sampler2D normalTex;
layout(set = 1, binding = 6) uniform sampler2D linDepthTex;

layout(set = 1, binding = 7) uniform samplerCube irradianceMap;
layout(set = 1, binding = 8) uniform samplerCube envMap;
layout(set = 1, binding = 9) uniform sampler2D brdfLut;

void main() {
	uvec2 pixel = gl_GlobalInvocationID.xy;
	uvec2 size = imageSize(outCol);
	if(pixel.x >= size.x || pixel.y >= size.y) {
		return;
	}

	vec2 pixelSize = 1.f / size;
	vec2 uv = (pixel + vec2(0.5, 0.5)) * pixelSize;
	vec4 color = imageLoad(outCol, ivec2(pixel));

	// apply emission
	vec4 vEmission = textureLod(emissionTex, uv, 0);
	vec3 emission = vEmission.rgb;
	color.rgb += emission;

	// reconstruct position
	float ld = textureLod(linDepthTex, uv, 0).r;
	float depth = ztodepth(ld, scene.near, scene.far);
	if(depth != 1.f && params.aoFactor > 0.f) {
		vec4 vAlbedo = texture(albedoTex, uv);
		vec3 albedo = vAlbedo.rgb;
		vec3 ambient = albedo;

		if((params.flags & flagDiffuseIBL) != 0) {
			vec4 vNormal = texture(normalTex, uv);
			vec3 normal = decodeNormal(vNormal.xy);
			float roughness = vNormal.w;
			float metallic = vEmission.w;

			vec2 suv = 2 * uv - 1;
			suv.y *= -1.f; // flip y
			vec4 pos4 = scene.invProj * vec4(suv, depth, 1.0);
			vec3 fragPos = pos4.xyz / pos4.w;
			vec3 viewDir = normalize(fragPos - scene.viewPos);

			// apply ao
			vec3 f0 = vec3(0.04); // NOTE: good enough, could be made material property
			f0 = mix(f0, albedo, metallic);

			float cosTheta = max(dot(normal, -viewDir), 0.0);
			vec3 kS = fresnelSchlickRoughness(cosTheta, f0, roughness);
			vec3 kD = 1.0 - kS;
			kD *= 1.0 - metallic;

			// ambient irradiance
			vec3 irradiance = texture(irradianceMap, normal).rgb;
			vec3 diffuse = kD * irradiance * albedo;

			// specular
			vec3 R = reflect(viewDir, normal);
			float lod = roughness * params.convolutionLods;
			vec3 filtered = textureLod(envMap, R, lod).rgb;   
			vec2 brdfParams = vec2(cosTheta, roughness);
			vec2 brdf = texture(brdfLut, brdfParams).rg;
			vec3 specular = filtered * (kS * brdf.x + brdf.y);
			  
			ambient = diffuse + specular;
		}

		float ao = params.aoFactor * vAlbedo.w;
		if((params.flags & flagSSAO) != 0) {
			ao *= pow(texture(ssaoTex, uv).r, params.ssaoPow);
		}

		color.rgb += ao * ambient;
	}

	// write back
	imageStore(outCol, ivec2(pixel), color);
}
