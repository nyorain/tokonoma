#version 450

// each workgroup reduces groupDimSize * 2 pixels in each dimension.
// therefore expects the output texture to be smaller by this factor
// e.g. if the specilization constant groupDimSize is 8 
// (solid choice usually), dimensions of outLim are smaller by factor 16.
// Can e.g. use 4th next mip level in that case.

// NOTE: we assume that x and y work group sizes are the same.
// There is no reason why we should choose something else and it
// simplifies the computation here tremendously
layout(local_size_x_id = 0, local_size_y_id = 0) in;
layout(set = 0, binding = 0) uniform sampler2D inLum;
layout(set = 0, binding = 0, r16f) uniform writeonly image2D outLum;

// contain the current summed-up luminance
shared float lum[gl_WorkGroupSize.x][gl_WorkGroupSize.x];

// constant for all invocations
uvec2 inSize = textureSize(inLum, 0);
uint size = gl_WorkGroupSize.x; // == gl_WorkGroupSize.y
vec2 pixelSize = 1.f / inSize;

// constant per group
// end of pixels processed
uvec2 pend = min(inSize - 2 * size * gl_WorkGroupID.xy, 2 * size.xx);
// local end of the work group
uvec2 lend = (pend + 1) / 2; // round up

void main() {
	uvec2 l = gl_LocalInvocationID.xy;
	if(l.x >= lend.x || l.y >= lend.y) {
		return;
	}

	vec2 pixel = 2 * gl_GlobalInvocationID.xy;
	// offset between pixels if possible
	// sample 4 pixels (normal case, corner/border only 1 or 2)
	vec2 off = clamp((inSize - pixel - 1), 0.5, 1.0); // detect border/corner
	float fac = 4 * off.x * off.y; // how many pixels sampled, in {1, 2, 4}
	pixel += off;

	lum[l.x][l.y] = fac * texture(inLum, pixel * pixelSize).r; // initial load
	while(lend.x > 1 || lend.y > 1) {
		lend = (lend + 1) / 2;
		if(l.x >= lend.x) {
			return;
		}

		// wait for initial load/last vertical reduce to complete
		// apparently both barriers needed:
		// https://stackoverflow.com/questions/39393560
		memoryBarrierShared();
		barrier();
		lum[l.x][l.y] += lum[lend.x + l.x][l.y];
		if(l.y >= lend.y) {
			return;
		}

		// wait for horizontal reduce above to complete
		memoryBarrierShared();
		barrier();
		lum[l.x][l.y] += lum[l.x][lend.y + l.y];
	}

	// there is only one invocation active at this point: l = (0, 0)
	float avg = lum[0][0] / (pend.x * pend.y);
	imageStore(outLum, ivec2(gl_WorkGroupID.xy), vec4(avg));
}
