#version 450

// TODO: make configurable
layout(local_size_x = 32, local_size_y = 32) in;
const float highPassThreshold = 0.5;

layout(set = 0, binding = 0) uniform sampler2D inLight;
layout(set = 0, binding = 1, rgba16f) uniform image2D outBloom;

void main() {
	uvec2 pixel = gl_GlobalInvocationID.xy;
	uvec2 size = imageSize(outBloom);
	if(pixel.x >= size.x || pixel.y >= size.y) {
		return;
	}

	vec2 pixelSize = 1.f / size;
	vec2 uv = (pixel + vec2(0.5, 0.5)) * pixelSize;
	vec4 bloom = imageLoad(outBloom, ivec2(pixel));
	vec3 light = texture(inLight, uv).rgb;

	// NOTE: not sure which norm works best here
	// should probably try all out; make this demo-configurable
	// float l = color.r + color.g + color.b;
	float l = length(light);
	// float l = max(color.r, max(color.g, color.b));

	if(l <= highPassThreshold) { // nothing to do here
		return;
	}

	// color *= pow(1 - (highPassThreshold / l), 2);
	// color *= 1 - (highPassThreshold / l);
	// color *= smoothstep(0.0, 1.0, l - highPassThreshold);
	// color *= (l - highPassThreshold);

	// NOTE: this one turns out to be be best.
	// the pow leads to pushing the color vector towards
	// length 1 (lower power means stronger towards 1).
	// this is important since otherwise single well-lit pixels
	// may create really bright bloom which leads to bloom popping
	// when moving
	light *= pow(l - highPassThreshold, 0.4) / l;
	bloom.rgb += light;
	imageStore(outBloom, ivec2(pixel), bloom);
}
