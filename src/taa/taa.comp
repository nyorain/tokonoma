#version 450

#extension GL_GOOGLE_include_directive : enable
#include "scene.glsl"

layout(local_size_x = 8, local_size_y = 8) in;

// alpha value of history is the linear depth
layout(set = 0, binding = 0) uniform sampler2D inHistory;
layout(set = 0, binding = 1, rgba16f) uniform writeonly image2D outHistory;
layout(set = 0, binding = 2) uniform sampler2D renderedTex;
layout(set = 0, binding = 3) uniform sampler2D depthTex; // non-linear, [0, 1]

layout(set = 0, binding = 4, row_major) uniform UBO {
	mat4 invProj;
	mat4 lastProj;
	vec2 jitter;
	vec2 lastJitter;
	float near, far;
} ubo;

uvec2 size = imageSize(outHistory);
vec2 pixelSize = 1.f / size;

// Luninance vector. dot(light.rgb, luminance) will be used to
// calculate the luminance. Must rerecord when changed.
// See https://stackoverflow.com/questions/596216 for a discussion
// about different conventions.
const vec3 luminanceFac = vec3(0.25, 0.65, 0.1);

#if 0
vec3 clip_aabb(vec3 aabb_min, vec3 aabb_max, vec4 p, vec4 q) {
	const float eps = 0.00000001f;

	// note: only clips towards aabb center (but fast!)
	vec3 p_clip = 0.5 * (aabb_max + aabb_min);
	vec3 e_clip = 0.5 * (aabb_max - aabb_min) + eps;

	vec3 v_clip = q - float4(p_clip, p.w);
	vec3 v_unit = v_clip.xyz / e_clip;
	vec3 a_unit = abs(v_unit);
	float ma_unit = max(a_unit.x, max(a_unit.y, a_unit.z));

	if (ma_unit > 1.0) {
		return float4(p_clip, p.w) + v_clip / ma_unit;
	} else {
		return q;// point inside aabb
	}
}

#else
vec3 clip_aabb(vec3 aabb_min, vec3 aabb_max, vec3 p, vec3 q) {
	vec3 r = q - p;
	vec3 rmax = aabb_max - p.xyz;
	vec3 rmin = aabb_min - p.xyz;

	const float eps = 0.00000001f;

	// NOPE
	// r *= clamp(rmax.x / r.x, 0, 1);
	// r *= clamp(rmax.y / r.y, 0, 1);
	// r *= clamp(rmax.z / r.z, 0, 1);
	// r *= clamp(r.x / rmin.x, 0, 1);
	// r *= clamp(r.y / rmin.y, 0, 1);
	// r *= clamp(r.z / rmin.z, 0, 1);

	if (r.x > rmax.x + eps)
		r *= (rmax.x / r.x);
	if (r.y > rmax.y + eps)
		r *= (rmax.y / r.y);
	if (r.z > rmax.z + eps)
		r *= (rmax.z / r.z);

	if (r.x < rmin.x - eps)
		r *= (rmin.x / r.x);
	if (r.y < rmin.y - eps)
		r *= (rmin.y / r.y);
	if (r.z < rmin.z - eps)
		r *= (rmin.z / r.z);

	return p + r;
}

#endif

void main() {
	// get pixel this invocation is responsible for
	// out of bounds can happen when image size isn't multiple of
	// work group size
	uvec2 pixel = gl_GlobalInvocationID.xy;
	if(pixel.x >= size.x || pixel.y >= size.y) {
		return;
	}

	// reconstruct world space using the depth buffer
	vec2 uv = (pixel + 0.5) * pixelSize; // center of pixel

	// read rendered pixel 
	vec2 j = 0.5 * ubo.jitter;
	j.y *= -1;
	vec2 juv = uv + j;
	float depth = texture(depthTex, juv).r;

	vec2 suv = 2 * uv - 1;
	// suv -= ubo.jitter;
	suv.y *= -1.f; // flip y, different directions in screen/world space
	vec4 pos4 = ubo.invProj * vec4(suv, depth, 1.0);
	vec3 world = pos4.xyz / pos4.w;

	vec3 color = texture(renderedTex, juv).rgb;
	// vec3 color = world;

	// try to find a matching pixel in the history buffer
	vec3 proj = multPos(ubo.lastProj, world);
	proj.y *= -1.f;
	// proj.xy += ubo.lastJitter;
	vec2 tc = 0.5 + 0.5 * proj.xy;

	if(tc == clamp(tc, 0, 1)) { // also skip for depth == 1.0?
		vec4 hist = texture(inHistory, tc);

		// using tap4
		const ivec2 off01 = ivec2(0, 1);
		const ivec2 off11 = ivec2(1, 0);

		vec3 c00 = textureOffset(renderedTex, juv, -off11).rgb;
		vec3 c10 = textureOffset(renderedTex, juv, -off01).rgb;
		vec3 c01 = textureOffset(renderedTex, juv, +off01).rgb;
		vec3 c11 = textureOffset(renderedTex, juv, +off11).rgb;
		// vec3 c2 = textureOffset(renderedTex, juv, +off11 + off01).rgb;
		// vec3 c3 = textureOffset(renderedTex, juv, -off11 - off01).rgb;

		vec3 cmin = min(color, min(c00, min(c10, min(c01, c11))));
		vec3 cmax = max(color, max(c00, max(c10, max(c01, c11))));
		// vec3 cmin = min(color, min(c00, min(c10, min(c01, min(c11, min(c2, c3))))));
		// vec3 cmax = max(color, max(c00, max(c10, max(c01, max(c11, max(c2, c3))))));
		// vec3 cavg = 0.25 * (c00 + c10 + c01 + c11);
		// vec3 cavg = (color + c00 + c10 + c01 + c11 + c2 + c3) / 7;
		vec3 cavg = (color + c00 + c10 + c01 + c11) / 5;

		// hist.rgb = clamp(hist.rgb, cmin, cmax);
		// hist.rgb = clip_aabb(cmin, cmax, clamp(cavg, cmin, cmax), hist.rgb);
		hist.rgb = clip_aabb(cmin, cmax, cavg, hist.rgb);

		// NOTE: psych!
		// hist.rgb = clip_aabb(2 * cmin, 2 * cmax, cavg, hist.rgb);

		const float minFeedback = 0.85;
		const float maxFeedback = 0.9999;

		float lum0 = dot(luminanceFac, color);
		float lum1 = dot(luminanceFac, hist.rgb);
		// float lmax = dot(luminanceFac, cmax);
		// float diff = abs(lum0 - lum1) / (0.001 + max(lum0, max(lum1, lmax)));
		float diff = abs(lum0 - lum1) / (max(lum0, max(lum1, 0.2)));
		diff = 1.0 - diff;
		float weight = mix(diff * diff, minFeedback, maxFeedback);

		// float weight = 1 - 0.01 * distance(cavg, color);
		// float weight = 1 - 0.1 * distance(hist.rgb, color);
		// float weight = 0.9;
		color = mix(color, hist.rgb, weight);
	} else {
		// color = vec3(1.0, 1.0, 0.0);
	}

	// debugging was fun.
	// if(any(isnan(color))) {
	// 	color = vec3(1.0, 0.0, 1.0);
	// }

	// write the result into the history buffer
	float z = depthtoz(depth, ubo.near, ubo.far);
	imageStore(outHistory, ivec2(pixel), vec4(color, z));
}
