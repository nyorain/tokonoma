#version 460

layout(local_size_x = 8, local_size_y = 8) in;

layout(set = 0, binding = 0) uniform sampler2D rendered;
layout(set = 0, binding = 1, rgba16f) uniform image2D history;

const float fac = 0.9;

vec3 clip_aabb(vec3 aabb_min, vec3 aabb_max, vec3 p, vec3 q) {
	vec3 r = q - p;
	vec3 rmax = aabb_max - p.xyz;
	vec3 rmin = aabb_min - p.xyz;

	const float eps = 0.00000001f;

	if (r.x > rmax.x + eps)
		r *= (rmax.x / r.x);
	if (r.y > rmax.y + eps)
		r *= (rmax.y / r.y);
	if (r.z > rmax.z + eps)
		r *= (rmax.z / r.z);

	if (r.x < rmin.x - eps)
		r *= (rmin.x / r.x);
	if (r.y < rmin.y - eps)
		r *= (rmin.y / r.y);
	if (r.z < rmin.z - eps)
		r *= (rmin.z / r.z);

	return p + r;
}

void main() {
	uvec2 size = imageSize(history);
	ivec2 id = ivec2(gl_GlobalInvocationID.xy);
	if(id.x >= size.x || id.y > size.y) {
		return;
	}

	// TODO: we really need a larger area to sample for this usecase,
	// there may be a lot of space between rays. We could sample one pixel
	// from a mip level of the rendered texture... but we only get
	// the average this way. Maybe use a compute shader that write
	// mix/max/avg for blocks into textures? And always take like
	// 8x8 blocks or something

	const vec2 offs[] = {
		vec2(1, 1),
		vec2(-1, 1),
		vec2(1, 0),
		vec2(0, 1),
		vec2(1, 2),
		vec2(2, 1),
		vec2(2, 0),
		vec2(0, 2),
	};

	// TODO: could use shared compute stuff here
	vec2 uv = vec2(id) / size;
	vec3 r = texture(rendered, uv).rgb;
	vec3 cmin = r;
	vec3 cmax = r;
	vec3 cavg = r;
	for(uint i = 0u; i < offs.length(); ++i) {
		vec2 off = offs[i] / size;
		vec3 c1 = texture(rendered, uv + off).rgb;
		vec3 c2 = texture(rendered, uv - off).rgb;
		cmin = min(cmin, min(c1, c2));
		cmax = max(cmax, min(c1, c2));
		cavg += c1 + c2;
	}

	cavg /= (1 + 2 * offs.length());

	// vec3 c00 = textureOffset(rendered, uv, -off11_1).rgb;
	// vec3 c10 = textureOffset(rendered, uv, -off01_1).rgb;
	// vec3 c01 = textureOffset(rendered, uv, +off01_1).rgb;
	// vec3 c11 = textureOffset(rendered, uv, +off11_1).rgb;
	// vec3 cmin = min(r, min(c00, min(c10, min(c01, c11))));
	// vec3 cmax = max(r, max(c00, max(c10, max(c01, c11))));
	// vec3 cavg = (r + c00 + c10 + c01 + c11) / 5;

	vec3 h = imageLoad(history, id).rgb;
	// h.rgb = clip_aabb(cmin, cmax, cavg, h.rgb);

	vec3 res = mix(r, h, fac);
	imageStore(history, id, vec4(res, 1));
}
