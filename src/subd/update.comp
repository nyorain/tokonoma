#version 460
#define FBM_OCTAVES 6

#extension GL_GOOGLE_include_directive : require
#include "noise.glsl"
#include "subd.glsl"

layout(set = 0, binding = 0) readonly buffer OldKeys {
	// uint counter;
	// float _pad;
	uvec2 keys[];
} old;

layout(set = 0, binding = 1) buffer NewKeys {
	uint counter;
	uint _pad;
	uvec2 keys[];
} new;

// NOTE: investigate already computing clipping and culling stuff here.
// We might need more update iterations per frame then, otherwise
// we get popping artifacts
layout(set = 0, binding = 2, row_major) uniform Scene {
	mat4 _vp;
	vec3 pos;
	uint update;
} scene;

// real scene:
layout(set = 0, binding = 3) buffer Vertices { vec4 vertices[]; };
layout(set = 0, binding = 4) buffer Indices { uint indices[]; };

// enough for our small dummy scene
// const vec3 vertices[] = {
// 	{-1, 0, -1}, // 4 outlining points ...
// 	{1, 0, -1},
// 	{1, 0, 1},
// 	{-1, 0, 1},
// };
// 
// const uint indices[] = {
// 	0, 1, 2,
// 	0, 2, 3
// };
// 

vec3 mapPos(uint ini, vec2 bary) {
	vec3 v_in[3] = vec3[3](
		vertices[indices[3 * ini + 0]].xyz,
		vertices[indices[3 * ini + 1]].xyz,
		vertices[indices[3 * ini + 2]].xyz
	);
 
	return berp(v_in, bary);
}

float desiredLOD(uint key, uint ini) {
	vec3 v_in[3] = vec3[3](
		vertices[indices[3 * ini + 0]].xyz,
		vertices[indices[3 * ini + 1]].xyz,
		vertices[indices[3 * ini + 2]].xyz
	);

	vec3 tri[3];
	subd(key, v_in, tri);
	float d0;
	vec3 d1;
	vec3 hyp = 0.5 * (displace(tri[1], d1, d0) + displace(tri[2], d1, d0));
	return distanceToLOD(distance(scene.pos, hyp));
}

void main() {
	uint id = gl_GlobalInvocationID.x;

	// assert(id < old.counter);
	uvec2 oldkey = old.keys[id];
	uint key = oldkey.x;
	uint ini = oldkey.y;

	uint klod = findMSB(key);
	uint plod = uint(desiredLOD(key == 1u ? key : key >> 1u, ini));
	uint dlod = uint(desiredLOD(key, ini));

	// vec2 ppos = 
	// uint plod = distanceToLOD(distance(scene.pos, ppos));

	// TODO: hack, not 100% sure why it's needed. Not mentioned in paper.
	// investigate. Probably indicates bug in consisten distance lod calc
	/*
	if((key & 1u) == 1u && (key != 1)) {
		uint sib = key;
		sib ^= 1u;
		uint sdlod = uint(desiredLOD(sib, ini));
		if(sdlod != dlod) {
			dlod = sdlod;
		}
	}
	*/

	// TODO: this is only for debugging/visualization
	// if we don't want to do the update step for performance reasons
	// we obviously shouldn't dispatch at all... but then also
	// not copy the dst buffer, i.e. requires to modify command buffer.
	// shame there is no such thing as indirect buffer copies
	/*
	if(scene.update == 0 || clod == dlod / * || clod - 1 == dlod* /) {
		new.keys[atomicAdd(new.counter, 1)] = uvec2(key, ini);
	} else if(clod < dlod) {
		// lod too low.
		// subdivide, i.e. add two children
		uint idx = atomicAdd(new.counter, 2);
		new.keys[idx + 0] = uvec2((key << 1u) | 0u, ini);
		new.keys[idx + 1] = uvec2((key << 1u) | 1u, ini);
	} else if(clod > dlod) {
		// lod too high, we don't need that much subdivision.
		// only one of the children will insert parent key
		if((key & 1u) == 1u) {
			key = key >> 1u; // get parent
			new.keys[atomicAdd(new.counter, 1u)] = uvec2(key, ini);
		}
	} else {
		// error
	}
	*/

	if(scene.update == 0) {
		new.keys[atomicAdd(new.counter, 1)] = uvec2(key, ini);
		return;
	}

	if(klod < dlod) {
		// subdivide
		uint idx = atomicAdd(new.counter, 2);
		new.keys[idx + 0] = uvec2((key << 1u) | 0u, ini);
		new.keys[idx + 1] = uvec2((key << 1u) | 1u, ini);
	} else if(klod < (plod + 1)) {
		// just write
		new.keys[atomicAdd(new.counter, 1)] = uvec2(key, ini);
	} else {  // merge
		if((key & 1u) == 1u) {
			key = key >> 1u; // get parent
			new.keys[atomicAdd(new.counter, 1u)] = uvec2(key, ini);
		}
	}
}
